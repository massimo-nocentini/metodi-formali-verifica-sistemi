

\section{Basic Definitions}

In this section we recall basic definitions used in the remaing part
of the \emph{qualitative project} paper.

\subsection{Stochastic Processes}

A \emph{stochastic process} $p$ is a $\mathcal{T}$-indexed family of
random variables $X_i$, formally $p = \{X_i: i \in \mathcal{T}\}$, in
particular $p$ is called \emph{discrete} if $\mathcal{T} = \mathbb{N}
$, otherwise $p$ is called \emph{continuous} if $\mathcal{T} =
\mathbb{R} $.


\subsection{Discrete Time Markov Chains}

A \emph{Discrete Time Markov Chain} (DTMC) is a discrete stochastic
process such that, given $\Omega$ a sample space, $X_i:\Omega
\rightarrow \mathbb{N}, \forall i\in \mathbb{N} $.
% Usually a DTMC is
% modeled with a tuple $(S, P, AP, L)$ such that:
% \begin{itemize}
% \item $S$ is a finite set of \emph{states};
% \item $P$ is a function such that $P:S\times S \rightarrow [0,1]$,
%   where $\sum_{v \in S}{P(s,v)} = 1, \forall s \in S $;
% \item $AP$ is a set of \emph{atomic propositions};
% \item $L$ is a function such that $L:S \rightarrow AP$.
% \end{itemize}

\section{Herman's Stabilization algorithm}

This paper study an algorithm about self-stabilization of
fault-tolerant systems in a distributed environment. We can abstract a
fault-tolerant system with a network of processes and the goal is to
build a protocol which, applied to an initial configuration $i$ of the
network, produces a new configuration $c$ such that:
\begin{itemize}
\item $c$ satisfies some property of interest;
\item the protocol requires a \emph{finite} number of steps to produce
  $c$;
\item there is no intervention of outside objects in order to produce
  $c$.
\end{itemize}
In the following section we state formally the problem described above
and the Herman algorithm under study. We've used the article \cite{
  KNP12a} to make our formalizations.

\subsection{Background}

Herman protocol \cite{Her90} is applied to a network of processes
$p_i$ where $i \in \{1,\ldots, n\}$, structured in an oriented ring
and ordered anticlockwise. This protocol is synchronous, that is
actions taken by each process $p_i$ happen simultaneously, no
interleaving are present. Following the presentation given by Herman,
it is possible to represent each process $p_i$ with a single
\emph{bit} $x_i$ and the entire network with a DTMC. With those basics
we're ready to introduce some concepts that we want to study with a
simulation using PRISM \cite{KNP11}.

We define a \emph{network configuration} as a state of the DTMC with
$n$ processes, so a tuple $(x_n, \ldots, x_1) \in \{0,1\}^n$. In the
ring may exist one or more processes that have \emph{tokens} and those
can be passed between processes $p_i$ and $p_{i+1}$ (so always to the
right neighbor). A process $p_i$ has a token if $x_i = x_{i-1}$ ($x_1
= x_n$ due to ring network structure). Finally, a network
configuration is \emph{stable} if $\exists! p_i$ that has a token.
\\\\
From the above definitions follow these facts:
\begin{itemize}
\item given a network with $n$ processes, the set of states $S$ of the
  underlying DTMC has cardinality $2^n$. This can be proved saying
  that each state $s\in S$ has $n$ components, each component has $2$
  possible value, hence $|S| = 2^n$;
\item given a network with $n = 2k+1$ processes, there no exists
  network configuration with $t=2j$ tokens. To see why we use a
  constructive proof:
  \begin{proof} Let $(x_n,x_{n-1}, \ldots, x_2,x_1)$ be a network
    configuration such that $n=2k+1$ and $(x_{n-1}, \ldots,x_2, x_1)$
    be a suffix with $t=2j$ tokens (which is perfectly legal, for
    instance $(0,0,1,1,0,0)$, with tokens in $p_6, p_4, p_2, p_1$).

    Suppose $x_1 = 0$ (the same argument may be applied for
    $x_1=1)$. We can have the following suffixes with even length:
    \begin{itemize}
    \item $(0,x_{n-2},\ldots, x_2,0)$, we can complete it by adding
      $x_n$ such that:
      \begin{itemize}
      \item $(0,0,x_{n-2},\ldots, x_2, 0)$ in this configuration there
        are $2j+1$ token (one more due to $(x_n,x_{n-1})$);
      \item $(1,0,x_{n-2},\ldots, x_2,0)$ in this configuration there
        are $2j-1$ token (one less due to breaking $(x_1,x_{n-1})$);
      \end{itemize}
    \item $(1,x_{n-2},\ldots, x_2,0)$, we can complete it by adding
      $x_n$ such that:
      \begin{itemize}
      \item $(0,1,x_{n-2},\ldots, x_2, 0)$ in this configuration there
        are $2j+1$ token (one more due to $(x_1,x_n)$);
      \item $(1,1,x_{n-2},\ldots, x_2,0)$ in this configuration there
        are $2j+1$ token (one more due to $(x_n,x_{n-1})$).
      \end{itemize}
    \end{itemize}
    Adding $x_n$ on configurations of even length we get $2j\pm 1 $
    tokens, which is an odd number.
  \end{proof}
\end{itemize}

\subsection{Protocol rule}

Let $k$ be a generic execution step, the protocol consists of the
following rule:
\begin{displaymath}
  \begin{split}
    x_{i}^{(k+1)} &:= x_{i-1}^{(k)} \quad &\text{if } x_{i}^{(k)} \not=
    x_{i-1}^{(k)}\\
    x_{i}^{(k+1)} &:= random(0,1) \quad &\text{if } x_{i}^{(k)} =
    x_{i-1}^{(k)}
  \end{split}
\end{displaymath}
where $x_{i}^{(k)}$ is the value of $x_i$ at step $k$, $:=$ means
assignment and $random$ is a function that simulate a unbiased coin
toss. In \autoref{table:herman-protocol-execution-example} we report a
simple example of protocol execution applied to 5 processes, starting
from the network configuration $(1, 1, 0, 0, 1)$.
\begin{table}[ht]
  \begin{center}
    \begin{tabular}{cccc}
      \hline
      step & $(x_5, x_4, x_3, x_2, x_1)$ & Tokens owners & coin tosses \\ 
      \hline     
      1 & $(1, 1, 0, 0, 1)$ & $p_5, p_3, p_1$ & $x_1^{(2)}:= 0,
      x_3^{(2)}:= 1, x_5^{(2)}:= 1$  \\
      2 & $(1, 0, 1, 1, 0)$ & $p_3$ & $x_3^{(3)}:= 0$  \\
      3 & $(0, 1, 0, 0, 1)$ & $p_3$ & $x_3^{(4)}:= 0$  \\
      4 & $(1, 0, 0, 1, 0)$ & $p_4$ & $x_4^{(5)}:= 0$  \\
      5 & $(0, 0, 1, 0, 1)$ & $p_5$ & $\ldots$  \\ 
      \hline
    \end{tabular}
    \caption{Example of protocol execution}
    \label{table:herman-protocol-execution-example}
  \end{center}
\end{table}

It is interesting to observe these facts:
\begin{itemize}
\item from network configurations $\forall i:x_i=0$ and $\forall
  i:x_i=1$ of length $n$, it is possible to reach every other state by
  applying the second case of the protocol rule;
\item the protocol doesn't stop when a stable network configuration is
  reached. In fact, in a stable configuration, let $p_i$ be the token
  owner: depending its coin tossing, $p_i$ can decide to pass the
  token to $p_{i+1}$ or to keep it another turn (in the example
  reported above, if at step 4 would have been $x_4^{(5)}:= 1$ the
  next configuration would have been $(0, 1, 1, 0, 1)$, with $p_4$
  token owner again);
\item in order to have an estimate number of steps necessary to reach
  a stable configuration we do a PRISM simulation, using the
  \emph{Confidence Interval} method, with 1000 samples. Looking at the
  log:
\begin{verbatim}
Path length statistics: average 5.4, min 1, max 29
\end{verbatim}
  So the average number of necessary steps for reaching a stable
  configuration is $5.4$.
\end{itemize}

\subsection{Interesting properties}

In this section we verify if Herman protocol satisfy some desired
properties, in particular if a stable configuration is eventually
reached and if it is reached within $k$ steps.

Before get deep into properties verification it is important to
understand that if we'd have used a \emph{qualitative} model checker
to verify if a stable configuration is \emph{always} eventually
reached, the result would be \emph{reject}. To see why, let the DTMC
be in the state $(1,1,1,1,\ldots,1,1)$ and, repeating the application
of rule two of the protocol, for all $p_i$ the toin coss results in
$1$, getting $(1,1,1,1,\ldots,1,1)$ again. There exists an infinite
path on the DTMC which catch the previous behavior, hence that path is
the counterexample for ``from the initial state
$(1,1,1,1,\ldots,1,1)$, is a stable configuration \emph{always}
eventually reached?''

\subsubsection{One initial state $(1,1,1,\ldots,1,1)$}

In \autoref{table:herman-initial-states-properties-results} we report
the properties that we've verified with PRISM, the label ``stable''
represent a predicate such that:
\begin{displaymath}
  \begin{split}
    \text{stable is true} \leftrightarrow 1 = &(x_1=x_2?1:0)+(x_2=x_3?1:0)+(x_3=x_4?1:0)+(x_4=x_5?1:0)\\
    &+(x_5=x_6?1:0)+(x_6=x_7?1:0)+(x_7=x_1?1:0)
  \end{split}
\end{displaymath}


\begin{table}[ht]
  \begin{center}
    \begin{tabular}{p{5cm}cc}
      \hline
      description & PRISM property  & result \\
      \hline     
      from the initial state, a stable state is reached with
      probability 1 & P>=1 [ F "stable" ] & true \\
      from the initial state, a stable state is reached within 10
      steps with probability 1 & P>=1 [ F<=10 "stable" ] & false\\
      from the initial state, a stable state is reached within 10
      steps with probability .5 & P>=.5 [ F<=10 "stable" ] & true\\
      from the initial state, what is the probability to reach a
      stable state within 10 steps? & P=? [ F<=10 "stable" ] & .8757\\
      what is the expected number of steps required for the
      self-stabilisation algorithm to reach a stable state? & R=? [ F
      "stable" ] & 5.4933\\
      \hline
    \end{tabular}
    \caption{Properties and their verification using a single initial
      state}
    \label{table:herman-initial-states-properties-results}
  \end{center}
\end{table}

\subsubsection{Multiple initial states}

In \autoref{table:herman-log-chunck-multi-initial-states} we report
the verification of the following property, which informally states:
``what is the maximum/minimum expected time to reach a stable state,
starting from any initial configuration in which there are k tokens?''
\begin{displaymath}
  filter(m, R=? [ F "stable" ], "k\_tokens") \quad m \in \{max, min\}
\end{displaymath}
that we've verified with PRISM considering all states of the DTMC as
an initial state. The label ``stable'' is the predicate defined in the
previous section and ``k\_tokens'' represent a predicate $tokens(k)$
such that:
\begin{displaymath}
  \begin{split}
    tokens(k) \text{ is true } \leftrightarrow k = &(x_1=x_2?1:0)+(x_2=x_3?1:0)+(x_3=x_4?1:0)+(x_4=x_5?1:0)\\
    &+(x_5=x_6?1:0)+(x_6=x_7?1:0)+(x_7=x_1?1:0)
  \end{split}
\end{displaymath}

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{cccc}
      \hline
      tokens & sat states (out of 128)  & maximum over filter &
      manimum over filter \\ 
      \hline     
      1 & 14 & 0 & 0 \\
      3 & 70 & 6.857 & 2.857  \\
      5 & 42 & 5.973 & 5.018  \\
      7 & 2 & 5.493 & 5.493  \\ 
      \hline
    \end{tabular}
    \caption{Property verification about multi initial states}
    \label{table:herman-log-chunck-multi-initial-states}
  \end{center}
\end{table}

In \autoref{fig:herman-plot-output} we report a plot of the results
shown in \autoref{table:herman-log-chunck-multi-initial-states}.
\begin{figure}[htb]
  \centering
  \includegraphics[width=13cm]{quantitative-project/max-min-expected-time-experiment.png}
  \caption{Max/min needed time to reach stable conf agains
    tokens quantity}
  \label{fig:herman-plot-output}
\end{figure}

\section{Dynamic power management}

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{cccccc}
      \hline
      action & step & time in state & q & sp & state reward  \\ 
      \hline
      - & 0 & 0.17529898470620078 & 0 & 1 & 0.0 \\
       request  & 1 & 0.005583448654568147 & 1 & 2 & 1.0 \\
       serve last  & 2 & 0.037968897997879614 & 0 & 1 & 0.0 \\ 
       request  & 3 & 0.0011703015064502159 & 1 & 2 & 1.0 \\
       serve last  & 4 & 0.012972810099631941 & 0 & 1 & 0.0 \\
       request  & 5 & 0.003987650608881992 & 1 & 2 & 1.0 \\
       serve last  & 6 & 2.1181000655402715 & 0 & 1 & 0.0 \\
       request  & 7 & 0.0037317138619604204 & 1 & 2 & 1.0 \\
       serve last  & 8 & 0.3315114804496303 & 0 & 1 & 0.0 \\
       request  & 9 & 0.010092541816370613 & 1 & 2 & 1.0 \\
       serve last  & 10 & 0.2910521865618801 & 0 & 1 & 0.0 \\
       request  & 11 & 0.009291265782564638 & 1 & 2 & 1.0 \\
       serve last  & 12 & 0.43564591071847647 & 0 & 1 & 0.0 \\
       request  & 13 & 0.0016771441351985598 & 1 & 2 & 1.0 \\
      \hline
    \end{tabular}
    \caption{Property verification about multi initial states}
    \label{table:herman-log-chunck-multi-initial-states}
  \end{center}
\end{table}
